---
layout: tocpost
title: 'x86 step-by-step example: FlareOn8 Ch 2'
categories: [FlareOn8, x86, Windows, circular bit shift, step by step, detailed,]
excerpt: 'In challenge #2, the task is to recover multiple files which were rendered useless by ransomware.
The included binary is a .exe file (Windows executable) that will decrypt/"fix" the data given the correct key. Solving this challenge requires analysis of the decryption algorithm (which consists of circular bit shifts and XOR).'
---
<div class = "myWay">
    <p>
        In challenge #2, the task is to recover multiple files which were rendered useless by 'ransomware'.
The included binary is a .exe file (Windows executable) that will decrypt/"fix" the data given the correct key. Solving this challenge requires analysis of the decryption algorithm (which consists of circular bit shifts and XOR). </p>
</div>

<div id="note">
    <p>
    NOTE: This post assumes the reader is familiar with the basics of x86 and can read Intel syntax (along with basics of C). <br> 
    
    <a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"> </a>
    
    </p>
</div>
    


## Chall. 02: known
#### Setup

![](/images/known.png)

Let's open up the [zipped file](https://github.com/mibho/mibho.github.io/raw/master/attachments/02_known.7z) (password: flare).

![image](https://user-images.githubusercontent.com/86342821/141599163-107e3457-8e2e-4679-95a8-2f1664d106b5.png)

We see there's a .exe file and a folder named "Files" in the archive. Extract both the folder and the .exe to some same directory and run the .exe file. 

***NOTE: IF YOU HAVE ANTIVIRUS PROTECTION ENABLED, IT MIGHT FLAG THE FILE AS MALICIOUS. IF SO, REFER TO "Operation did not complete successfully..?" BELOW.***

<div id= "mainbar">
<details> 
    <summary> 
<h5>Operation did not complete successfully because the file contains a virus or potentially unwanted software.</h5>
  </summary>
  <p> 
      If you received the error message shown below, <b> don't worry . It's a false-positive, not a virus. </b> If the file disappears after seeing this error, it's because by default, AVs will quarantine or remove files they "detect".
      <img src="https://user-images.githubusercontent.com/86342821/141606716-9553dbd2-a9cb-4299-a5b7-ded9fad4f1f1.png">
  </p>
    <p>
        To solve this, you will need to temporarily <b> disable </b> Windows Defender. <a href="https://support.microsoft.com/en-us/windows/turn-off-defender-antivirus-protection-in-windows-security-99e6004f-c54c-8509-773c-a4d776b77960">You can do so by following the instructions in this link.</a> 
        If you have a different AV (e.g: Avast, AVG, etc) and you're unable to run the file, you may have to google for help on temporarily disabling your AV.
    </p>
    
</details>
    </div>

## Pre-Analysis
#### Context? What are we dealing with?

Opening the .exe produces a command prompt as shown below:

![image](https://user-images.githubusercontent.com/86342821/141667259-af364210-d207-4c16-b825-00fc3998aa07.png)

It looks like the files we need to restore are whatever are inside the folder "Files". If we check out the folder "Files", we see that there are 6 files (supposedly 2 of each: png, txt, gif) with a ".encrypted" extension at the end.

![image](https://user-images.githubusercontent.com/86342821/141721027-52449c4a-3a99-464e-8f2e-f5be8d868554.png)

Out of these files, the one that caught my eye was the "latin_alphabet.txt.encrypted". If my hunch is correct, then decrypting this text file should result in the Latin alphabet: **26 letters from A to Z.** Since ".encrypted" isn't a recognized file extension like .exe or .pdf, to look at its contents, we'll use a hex editor. 

Opening it yielded the following: 

![image](https://user-images.githubusercontent.com/86342821/141722484-eba6881b-f1eb-4540-aae9-ca36a9337932.png)

26 bytes (just like 26 letters in the alphabet) which makes me more confident about my hunch.  

If we look back at the message provided on the command prompt, we're told that the provided string is encoded in base64:

![image](https://user-images.githubusercontent.com/86342821/141731550-d0015acf-4abb-4bf7-a4d7-484ade595c08.png)

Let's copypaste the base64 blob and see what it says:

> KD4wXzApPiBJdCdzIGRhbmdlcm91cyB0byBhZGQrcm9yIGFsb25lISBUYWtlIHRoaXMgPCgwXzA8KQo=

Decoding it gives us the following message:

> (>0_0)> It's dangerous to add+ror alone! Take this <(0_0<)

<div class = "myWay"> <img src="/images/patrickthink2.png"> </div> 

Hmm.. I've never seen "ror" before, but I know the message is meant to help us approach this challenge [since it's based off the quote from Zelda](https://en.wikipedia.org/wiki/It%27s_dangerous_to_go_alone!).

We came across a clue which provided some insight on this program, but we still don't know much. So let's just try anything:

![image](https://user-images.githubusercontent.com/86342821/141738714-8d535bdb-7559-494a-9f91-a072cf28a11e.png)

For instance, I'll try entering "123456" as the encryption key and see what happens. Does something happen? 

![image](/images/123456.gif)

It seems to output a few lines and then immediately exits. Let's take a look at the Files folder:

![image](https://user-images.githubusercontent.com/86342821/142032698-44e7e5ba-b098-40dd-8e70-14c971213a91.png)

Now there are files without the ".encrypted" extension. Unfortunately that didn't fix anything (img files still not recognized and txt output is still cryptic). Decoding the files with "123456" transformed the Latin alphabet text file into: 

![image](https://user-images.githubusercontent.com/86342821/141744501-0ab0acb9-ffec-413e-b0d5-8cf4739f7081.png)

which doesn't correspond to A-Z. It's safe to assume "123456" was not the key we needed. So what now..? 

Well, we have a basic understanding of the program so we kind of know what to expect. We can use that to piece together information we'll come across from loading the file in a disassembler. 


## Analysis



#### Identifying our function(s) of interest

Load the .exe. The program consists of 9 functions.

![image](https://user-images.githubusercontent.com/86342821/141760450-d7dea7f5-8a21-49d5-aa65-3b9a5a665ce0.png)

Let's begin with start:

![image](https://user-images.githubusercontent.com/86342821/141762633-cd8d8c88-754f-44b7-9064-17c249ca838f.png)


<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    
    
  <div id ="submainbar">
      <details> 
    <summary> 
<h5> Part 1 </h5>
  </summary>
      <p> 
          <img src="https://user-images.githubusercontent.com/86342821/141766542-5b726f91-aa8f-4630-bc14-cf83445e2df5.png"> 
      </p>
          
          <p> 
         
          The 1st two instructions are referred to as the <b>function prologue</b>. This basically just prepares the stack. <a href="https://mibho.github.io/2019-7-27-denoobifyx86/">How? Read more.</a> <br>
          <p class= "lolwat2"> sub esp, 10h <span class="lolwat">allocates 10h (16) bytes of space on the stack.</span>      
          </p>           
          
          <p class="lolwat2">xor eax, eax <span class="lolwat"> is the equivalent of eax = 0.  <a href="https://stackoverflow.com/questions/1396527/what-is-the-purpose-of-xoring-a-register-with-itself">It's typically used as an optimization since it's more efficient than mov eax, 0.</a> </span> 
          </p>
          
          <p class="lolwat2"> mov [ebp+Buffer], eax <span class="lolwat"> Since eax = 0 from the previous instruction, this is just setting the local variable Buffer to 0; ie, Buffer = 0.</span> 
          </p>
          
          <p class="lolwat2">mov [ebp+var_C], eax <span class="lolwat"> basically var_C = 0, for the same reason provided above. </span> 
          </p>
         
          <p class="lolwat2"> push 0FFFFFFF6h <span class="lolwat"> this hex value, 0FFFFFFF6h, is equivalent to 4294967286, which can be represented as ((DWORD)-10). This is the value of STD_INPUT_HANDLE (input buffer to console). So STD_INPUT_HANDLE is pushed to the top of the stack.</span> 
          </p>
          
          <p class="lolwat2">call ds:GetStdHandle <span class="lolwat"> basically GetStdHandle(STD_INPUT_HANDLE). GetStdHandle is called and the argument that's passed through is 0FFFFFFF6h.  </span> 
          </p>
          
          <p class="lolwat2"> mov 
              <br> [ebp + hConsoleInput], eax <span class="lolwat"> Since eax contains the return value of the function that was most recently executed (in this case, GetStdHandle), eax contains whatever GetStdHandle() returns. GetStdHandle(STD_INPUT_HANDLE) returns the handle to standard input (console) OR returns the constant INVALID_HANDLE_VALUE depending on success or fail, respectively. so eax = handle to standard input or error. This is then stored into the local variable hConsoleInput. </span> 
          </p>
          
          <p class="lolwat2">push 0FFFFFFF5h <span class="lolwat"> refer to explanation from push 0FFFFFFF6h above. The only difference is that 0FFFFFFF5h = STD_OUTPUT_HANDLE. </span> 
          </p>
          
         <p class="lolwat2"> call ds:GetStdHandle <span class="lolwat"> basically GetStdHandle(STD_OUTPUT_HANDLE). refer to explanation from previous GetStdHandle instruction with STD_INPUT_HANDLE.  </span> 
          </p>
          
          <p class="lolwat2">mov hConsoleOutput, eax <span class="lolwat">  so hConsoleOutput contains the result from GetStdHandle(STD_OUTPUT_HANDLE). </span> 
          </p>
          
   <br>
      
      Putting all the information together, these instructions return the handles to std_in and std_out (if valid).
          
      </p>
    </details>
    </div>
   
    <div id ="submainbar">
    <details> 
    <summary> 
<h5> Part 2 </h5>
  </summary>
        <p> <img src="https://user-images.githubusercontent.com/86342821/141786928-6b787445-0dec-48d5-aacd-798a32ef6402.png"> </p>
       
        <p>
            If we look up SetConsoleTextAttribute, we can see that the function is defined as follows: <br>
            BOOL WINAPI SetConsoleTextAttribute(_In_ HANDLE hConsoleOutput,  _In_ WORD   wAttributes); <br>
            Note that WINAPI is just another name for <b> __stdcall; ie, arguments are passed right to left </b> on the stack. In this case, that means wAttributes is placed on the stack before hConsoleOutput.<br> 
        </p>
            
            <p class="lolwat2">push 0CEh <span class="lolwat"> the value 206 (decimal) is put on the stack. This corresponds to wAttributes due to the __stdcall calling convention(rightmost argument is pushed first). </span> 
        </p>
        
        <p class="lolwat2">mov ecx, hConsoleOutput<span class="lolwat"> the handle to the standard output device (console) is stored in ecx. </span> 
          </p>
          
        <p class="lolwat2">push ecx<span class="lolwat"> ecx is then put on the stack. This corresponds to hConsoleOutput. </span> 
          </p>
        
            <p>
            Hold up... "<b>I thought ECX was typically used for keeping count of something?</b>" <br>
            Unfortunately, I'm not certain if this is correct, but by definition, 
        <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall"> __stdcall/WINAPI functions are allowed to modify eax, ecx, and edx.</a>
        As a result, ecx is saved prior to calling said function so that it can restore ecx in case the function that was just called modified its value. <br>
        ecx <b>is typically used as a counter</b>, but it can <b>also be used for temporary storage</b>. This scenario might be a "kill 2 birds with 1 stone" one? Pushing ecx would: <br>
            1) save its value on the stack so that even after the function call, we're able to retrieve it if needed. <br>
            2) put the 2nd argument on the stack. 
        </p>

            <p class="lolwat2">call <br> ds:SetConsoleTextAttribute<span class="lolwat"> basically SetConsoleTextAttribute(ecx, 0xCE), which modifies the background color of the console. </span> 
            </p>
        
       
        
        
    </details>
    </div>
    
    <div id ="submainbar">
    <details> 
    <summary> 
<h5> Part 3 </h5>
  </summary>
        <p> <img src="https://user-images.githubusercontent.com/86342821/141811593-3e046419-0cbd-44e1-a897-35fb5cc8a302.png"> </p>

        <p class="lolwat2">push 0<span class="lolwat"> put the number 0 onto the stack. </span> 
          </p>
        
        <p class="lolwat2">push 0<span class="lolwat"> put the number 0 onto the stack (again).  </span> 
          </p>
        
        <p class="lolwat2">push 70Ah<span class="lolwat"> put the number 70Ah [decimal: 1802] onto the stack.  </span> 
          </p>
        
        <p class="lolwat2">push offset_asc403000<span class="lolwat"> put offset_asc403000 onto the stack. </span> 
          </p>
        
        <p class="lolwat2">mov edx, hConsoleOutput<span class="lolwat"> store hConsoleOutput into EDX. </span> 
          </p>
        
        <p class="lolwat2">push edx<span class="lolwat"> put EDX onto the stack. </span> 
          </p>
        
        <p class="lolwat2">call ds:WriteConsoleA<span class="lolwat">  call WriteConsoleA with all of the arguments pushed onto the stack above.</span> 
          </p>
        
        <p> 
             
            Looking up WriteConsole, we get: BOOL WINAPI WriteConsole(_In_ HANDLE  hConsoleOutput,
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀    ⠀⠀⠀⠀⠀⠀⠀ _In_ const VOID *lpBuffer, ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀     ⠀⠀  _In_ DWORD   nNumberOfCharsToWrite,⠀⠀⠀⠀⠀⠀⠀
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀_Out_opt_  LPDWORD lpNumberOfCharsWritten,
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀_Reserved_ LPVOID  lpReserved);
            
            <br>
            Again, since it's WINAPI/__stdcall, arguments are passed in from right to left. This means: <br>
            lpReserved = 0; <br>
            lpNumberOfCharsWritten = 0; <br>
            nNumberOfCharsToWrite = 70Ah; <br>
            lpBuffer = offset_asc403000; <br>
            hConsoleOutput = edx; <br> 
            which yields: <br>
            WriteConsoleA(hConsoleOutput, offset_asc403000, 70Ah, 0, 0); <br> <br> 
            
            Since WriteConsoleA() outputs lpNumberOfCharsWritten characters from lpBuffer onto hConsoleOutput, it prints 1802 characters (the entire ransomware msg displayed on the command prompt) from a variable [ie, offset_asc403000] onto the console. 
            
            <br><br><br>
            
            <img src="https://user-images.githubusercontent.com/86342821/141811901-61eee70c-c244-46ef-9241-347ef427e199.png"> <br>
            
            
            
            Similarly, for ReadConsoleA, we get: BOOL WINAPI ReadConsole( _In_ HANDLE  hConsoleInput,
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀    ⠀⠀⠀⠀⠀⠀⠀ _In_ const VOID *lpBuffer, ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀    ⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀ _Out_ LPVOID lpBuffer,⠀⠀⠀⠀⠀⠀⠀
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀_In_ DWORD nNumberOfCharsToRead,
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀_Out_LPDWORD lpNumberOfCharsRead, ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ _In_opt_ LPVOID pInputControl);
            
            <br> 
            <br> 
            Once again, arguments are passed in from  right to left. <br>
            
            <p class="lolwat2">push 0<span class="lolwat"> corresponds to parameter pInputControl. put 0 on the stack.</span> 
          </p>
        
        <p class="lolwat2">lea eax, 
            <br> [ebp+NumberOfCharsRead]<span class="lolwat"> loads the address of NumberOfCharsRead into eax </span> 
          </p>
        
         <p class="lolwat2">push eax<span class="lolwat"> corresponds to parameter lpNumberOfCharsRead. puts the address of NumbersOfCharsRead on the stack.</span> 
          </p>
         <p class="lolwat2">push 8<span class="lolwat"> corresponds to nNumberOfCharsToRead = 8. put 8 on the stack.</span> 
          </p>
         <p class="lolwat2">lea ecx, [ebp+Buffer]<span class="lolwat">loads the address of Buffer into ecx.</span> 
          </p>
         <p class="lolwat2">push ecx<span class="lolwat"> corresponds to parameter lpBuffer.</span> 
          </p>
         <p class="lolwat2">lea edx,<br> 
             [ebp+hConsoleInput]<span class="lolwat"> loads the address of hConsoleInput into edx.</span> 
          </p>
         <p class="lolwat2">push edx<span class="lolwat"> corresponds to hConsoleInput.</span> 
          </p>
        
         Just like what we did above for WriteConsoleA(), ReadConsoleA() would then yield: <br> 
            
            ReadConsoleA(hConsoleInput, Buffer, 8, lpNumberOfCharsRead, 0); <br>  
            
            The interesting thing here is that ReadConsoleA() will only read 8 bytes since nNumberOfCharsToRead = 8.. 
            
        </p>
    </details>
    </div>
    
    <div id ="submainbar">
    <details> 
    <summary> 
<h5> Part 4 </h5>
  </summary>
       <p> <img src="https://user-images.githubusercontent.com/86342821/141812730-20dca27d-ea73-471e-87ed-ad14413cb23a.png"> </p>
        <p>
    
          <p class="lolwat2">lea eax, [ebp+Buffer]<span class="lolwat">loads the address of Buffer into eax.</span> 
          </p>
          <p class="lolwat2">push eax<span class="lolwat">save the value of eax [addr of Buffer] onto the stack and pass it as an argument for sub_401370</span> 
          </p>
          <p class="lolwat2">call sub_401370 <span class="lolwat">is equivalent to call 0x401370. This is broken down into: <b>push eip, jmp someFunc</b>, where in this case, someFunc = sub_401370. [eip aka <b> return address </b> is saved to be able to come back after jumping to a different address]</span> 
          </p>
          <p class="lolwat2">add esp, 4<span class="lolwat"> "undo" push eax by "deleting" its value.</span> 
          </p>
          <p class="lolwat2">push eax<span class="lolwat">stores eax (result of sub_401370) onto the stack, overwriting the previous value.</span> 
          </p>
          <p class="lolwat2">call ds:ExitProcess<span class="lolwat">ds refers to <b> data segment </b>; ExitProcess is executed.</span> 
          </p>
          
           
            
            
        </p>

    </details>
    </div>
    
</details>
    </div>

There are 4 main parts to this function:

1) Handles to the **standard input device** (console input buffer) and **standard output device** (console output buffer) are obtained using [*GetStdHandle()*](https://docs.microsoft.com/en-us/windows/console/getstdhandle)

```
GetStdHandle(STD_INPUT_HANDLE) // STD_INPUT_HANDLE is equivalent to ((DWORD)-10)

GetStdHandle(STD_OUTPUT_HANDLE) // STD_OUTPUT_HANDLE is equivalent to ((DWORD)-11)
```

2) Properties of the standard **output** device are modified using the handle to the console output obtained from the previous part and calling [*SetConsoleTextAttribute*](https://docs.microsoft.com/en-us/windows/console/setconsoletextattribute) with a value of 0xCE (206 decimal). This changes the program's text and background to the colors it's now set to (red background w/ light text). 

```
SetConsoleTextAttribute(hConsoleOutput, 0xCE)
```

3) The ransomware message is printed using the standard output device and calling [*WriteConsoleA*](https://docs.microsoft.com/en-us/windows/console/writeconsole) as follows:

```
WriteConsoleA(hConsoleOutput, asc_403000, 0x70A, 0, 0) // message is 0x70A (1802 decimal) characters long.

```

The user is then prompted to provide input of a decryption key, which is achieved by calling [*ReadConsoleA*](https://docs.microsoft.com/en-us/windows/console/readconsole) with the standard input device obtained from the 1st part. More specifically:

```
ReadConsoleA(hConsoleInput, Buffer, 8, NumberOfCharsRead, 0) 
```

so a max of ***8 characters*** is used, no matter how many characters are entered. 

4) The provided input is then used as an argument for some function, does something, and then exits.

```
sub_401370(&Buffer)
```





Near the end of start() we see that the function listed above is executed.

But what is *sub_401370()*..? As of now we don't know much, but:

![image](https://user-images.githubusercontent.com/86342821/142037786-31169186-489a-4794-ac40-374a2b16c95e.png)

the result of this function is used as an argument for ExitProcess(), so I'm confident [it represents the exit code of the program](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess).

Instead of dealing with the default names for the functions (sub_address), I will be renaming them so that keeping track of them is easier. Since **sub_401370() returns a value for ExitProcess(), I'll call it doesSomethingAndRetExitCode()**.  

![image](https://user-images.githubusercontent.com/86342821/143190423-6878f1bd-9c49-44da-a976-7be2ce400d29.png)

<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    
    <p> <img src="https://user-images.githubusercontent.com/86342821/143732516-fbc8532c-7a80-430f-a506-7dd5da9d8c17.png">
    </p>
    
    <p>
    Let's establish a basic visual so we can have a better understanding of what's going on. First, we're going to take a few steps back and start at the following:
        
        <img src="https://user-images.githubusercontent.com/86342821/143732639-9e09dd82-94ea-431f-8aa1-b3b321d86933.png">
    
    This is right before we call sub_401370/doesSomethingAndRetExitCode(). Suppose our stack frame looks something like this:
        
        <img src="https://user-images.githubusercontent.com/86342821/143732841-cb8b9d09-b8f2-40a6-9336-7db878c8a020.png">
        
     [Assume EBP and ESP are pointing to the correct things; ie, EBP to the base/start of the function frame and ESP to the topmost item on the stack].<br>Let's start from <b> push eax </b> and keep track of the stack frame.<br> After 
        <b> push eax </b> is executed, we get: <br>
        <b> NOTE: EAX is &Buffer after the LEA instruction </b>
        
         <img src="https://user-images.githubusercontent.com/86342821/143733118-224babfc-ad34-48ce-bfec-f0eca61be849.png">
        
        After <b> call sub_401370 </b>:
        
         <img src="https://user-images.githubusercontent.com/86342821/143943585-8eb60d35-8cbf-446e-a3da-7a9caa5a614b.png">
        
        We're now back to where we started. Let's go step by step and start from the top: <br>
        
        after <b> push ebp </b> <br>
        (We're saving the "old" EBP's value so we can restore it later on at the end of the function). 
        
         <img src="https://user-images.githubusercontent.com/86342821/143733633-81111aed-dc16-4c04-b593-722249e303b6.png">
        

        
        <b>after mov ebp, esp: </b>
        
         <img src="https://user-images.githubusercontent.com/86342821/143734002-7429c2a2-9e16-4135-9ee2-dea04a7d8066.png">
        
        after <b> sub esp, 190h: </b> <br>
        (190h (400 decimal) bytes are allocated for local variable storage). 
         <img src="https://user-images.githubusercontent.com/86342821/143734134-aed98a88-d64f-432f-99c3-c702e0700ca1.png"> <br>
        
        By "filling in the blanks", we have the following:
        
         <img src="https://user-images.githubusercontent.com/86342821/143734201-f270be33-240b-48a4-9789-b6dc1d60b72a.png">
        
        Let's continue on with the instructions:
        
        <img src="https://user-images.githubusercontent.com/86342821/143951011-142c5e61-8a85-4bec-9ae5-9cf781d99a6c.png">
        
        After <b>mov [ebp + var_4], 0 </b>:
        
        <img src="https://user-images.githubusercontent.com/86342821/143952222-8e6640a5-cbed-4955-920d-528455573a61.png">
        
        After <b> push offset PathName </b>:
        <img src="https://user-images.githubusercontent.com/86342821/143960195-d3051d89-4995-434c-b2cc-bf0f2ede2165.png">
        
        After <b> Call ds: SetCurrentDirectoryA </b>, <br>
        Since only 1 argument was pushed onto the stack, we have: <br>
        
        ⠀⠀⠀⠀⠀SetCurrentDirectoryA(PathName); <br>
        
        with the stack looking like how it was prior to the call. The main thing is that we have the result of the call in register <b> EAX </b>. <br> <br>
        
        After <b>test eax, eax </b>, <br>
        the appropriate flags are set depending on the result. these flags determine which branch will be taken by checking the conditions of the next instruction: <br> <br>
        
        <b> jnz short loc_401399 </b>. <br> 
        JNZ = jmp if not zero; ie, ZF (zero flag) = 0 aka not set. Since <b> test eax, eax </b> is the equivalent of eax & eax (bitwise-AND), the zero flag is set only if eax == 0. B/c EAX is the result/return value of SetCurrentDirectoryA, <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory">what happens depends on whether or not SetCurrentDirectoryA succeeded or failed. </a> <br> <br>
        (EAX = 0 if SetCurrentDirectoryA fails, non-zero otherwise. So for the zero flag to <b> not </b> be set, SetCurrentDirectoryA has to return a non-zero value, aka be successful)
        











    
    </p>
    
 </details>
    </div>

At the start of doesSomethingAndRetExitCode(), [SetCurrentDirectoryA()](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory)  attempts to change directories to the "Files" folder. Upon success, it returns a non-zero value and continues onto **loc_401399**. On failure, it returns zero and executes *sub_4010C0()*. **I'm not concerned with what happens if the program fails to change directories**; ie, sub_4010C0 is called (my reasoning was that the program won't be able to modify the files if it can't have access to them in the first place). Also, it doesn't check for the following scenarios:

1. is there a chance that the files are already in the current directory?
2. is there a chance that the program is already in the "Files" directory?

Let's take a quick look through sub_4010C0 to see if we come across anything that might give us a basic understanding of the function: 

![image](https://user-images.githubusercontent.com/86342821/142809804-97fa6d31-9bd3-4847-abaf-ee7e8ff681b4.png)

I quickly notice **GetLastError()** and multiple calls to **WriteConsoleA()**. In addition, there are two offsets which seem to deal with **error messages** and are passed through WriteConsoleA.  

<div class = "myWay"> <img src="/images/duckthinkright.png"> </div>

Hmm... 

For now, I'll name **sub_4010C0 as printsError** and return to it later if needed. [GetLastError()](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) outputs more information about the fail that occurred so I'm assuming with all the calls to WriteConsoleA, sub_4010C0 (printsError) does just that: print errors.

Since we discovered earlier (from running the program) that the result is a separate set of the supposedly decrypted files, I know that I'm going to be on the lookout for things related to file modification/access.

Let's return back to **doesSomethingAndRetExitCode()** and consider the branch that runs upon success: 

![image](https://user-images.githubusercontent.com/86342821/142827225-99cca5ab-695e-44ec-88cb-cfae3a2733d1.png)

<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    <p>
        Continuing off the stack frame made earlier (<b> AFTER push eax is executed </b>): <br>
        <img src="https://user-images.githubusercontent.com/86342821/143999563-a68a94bb-3c3a-498b-9d82-d41445019182.png"> <br>

    <img src="https://user-images.githubusercontent.com/86342821/143984374-abe51b78-2c87-4acf-b644-1ad54b6e2b87.png">
   
           <p class="lolwat2">lea eax, [ebp+FindFileData]<span class="lolwat">loads the address of FindFileData into eax. (points to start of FindFileData block shown in diagram) </span> 
          </p>
    
          <p class="lolwat2">push eax<span class="lolwat">save the value of eax [addr of FindFileData] onto the stack and pass it as the rightmost argument for FindFirstFileA.</span> 
          </p>
    
    <p class="lolwat2">push offset FileName<span class="lolwat">pass FileName as the 1st argument onto the stack for FindFirstFileA.</span> 
    </p>
    
    <p>
    Then after <b> call ds:FindFirstFileA </b>, our stack frame looks like: 
    <img src="https://user-images.githubusercontent.com/86342821/143994140-481402ff-1dc6-4b8a-be12-35bfd1780126.png">
    and the result of FindFirstFileA is in <b>EAX </b>. <br>
    </p>
    
    <p>
        If successful, EAX contains a valid search handle. Otherwise, EAX is equal to <b>INVALID_HANDLE_VALUE</b> 
    </p>
    
    <p class="lolwat2">mov [ebp + hFindFile], eax <span class="lolwat">The result of FindFirstFileA is stored in the local variable hFindFile (see below). </span> 
    </p>
        
        <img src="https://user-images.githubusercontent.com/86342821/143996787-69031cd3-4358-4cb7-a81c-15dbd893d8cc.png">

     <p class="lolwat2">cmp [ebp + hFindFile], <br> 0FFFFFFFh <span class="lolwat">The result of FindFirstFileA is compared to <b> INVALID_HANDLE_VALUE (0x0FFFFFFF) </b> and flags are set accordingly. Zero flag is set if the value stored in hFindFile is equal to 0x0FFFFFFF.</span> 
          </p>
    
         <p class="lolwat2">jnz loc_4013BE<span class="lolwat">The jump to loc_4013BE is taken only if the zero flag is <b> NOT </b> set; ie, ZF = 0. This means we want hFindFile's value to be anything other than 0x0FFFFFFF. In other words, we take the jump if we obtained a valid handle (hFindValue != 0x0FFFFFFF)  </span> 
          </p>
    
    </p>
 </details>
    </div>

Here we see [FindFirstFileA](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea) is called and looks for ".encrypted" files. If successful, it returns an argument (search handle) to be used for [FindNextFileA](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findnextfilea). Otherwise, *INVALID_HANDLE_VALUE* (*0x0FFFFFFF*) is returned. If a valid handle is returned (successful), we jump to **loc_4013BE** and move forward. If not, **printsError()** is executed. Since we established this function as one we aren't interested in, let's take the jump:

![image](https://user-images.githubusercontent.com/86342821/144711922-1a7bd914-c44e-41c3-a3fe-f06669432dbe.png)

<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    
    <div id ="submainbar">
    <details> 
    <summary> 
<h5> Part 1 </h5>
  </summary>
        <p>
        Let's recall the stack frame from the previous note and update it as we go along: 
            <img src="https://user-images.githubusercontent.com/86342821/143994140-481402ff-1dc6-4b8a-be12-35bfd1780126.png">
            <br> 
            <br>
     
        <img src="https://user-images.githubusercontent.com/86342821/144003790-8aa76ef3-420e-48e6-9725-63258e41ce30.png">
          Starting from the beginning:
            <p class="lolwat2">lea ecx, [ebp + FindFileData.cFileName]<span class="lolwat">load the address of the start of the char array (cFileName) into ecx .</span> 
            </p>
            <p class="lolwat2">push ecx<span class="lolwat">pass FileName (name of the file) as the rightmost argument onto the stack for sub_401030 (renamed as retNumBytesArg1ReplByArg2 in a few steps).</span> 
            </p>
        
        After <b>push ecx </b>, the stack frame looks like:
        <img src="https://user-images.githubusercontent.com/86342821/144033676-1da36c99-1e9f-4357-95f5-2d0b215ca120.png"> <br> 
        
        The 2nd argument is then passed: <br>
        <p class="lolwat2">lea edx, [ebp + var_50]<span class="lolwat">load the address of var_50 into edx.</span> 
            </p>
            <p class="lolwat2">push edx<span class="lolwat">pass the address of var_50 which corresponds to the beginning of the array; ie, var_50[0]. </span> 
            </p>
        and the stack frame looks as follows: 
        <img src="https://user-images.githubusercontent.com/86342821/144036273-a4577dd5-4632-4292-9e34-271e0f6c7d3a.png"> <br>
        
        Putting this all together, we get:
        <p class="lolwat2"> call sub_401030 <span class="lolwat"> sub_401030(&var_50, FindFileData.cFileName) </span> 
            </p>
        
        Note: there's also the following instruction after the call:
        <p class="lolwat2"> add esp, 8 <span class="lolwat"> This "cleans up" the space previously taken by the two push instructions. see stack frame below. </span> 
            </p>
        
        Adding 8 to ESP achieves the following (refer to right one): <br>
        
        <img src="https://user-images.githubusercontent.com/86342821/144042547-ff5472d8-491f-4a0c-b5c3-2ad6e4f31c70.png"> <br> 
        
        The data we wrote earlier is still there but we just cant access it anymore. (data will be overwritten. refer to part 2)
        
        </p>
        </details>
    </div>
    
    <div id ="submainbar">
    <details> 
    <summary> 
<h5> Part 2 </h5>
  </summary>
        <p>
        <img src="https://user-images.githubusercontent.com/86342821/144708750-bef83c63-da26-4292-b01d-279e764583f0.png">
        Unfortunately, I'm not sure why the 2nd mov instruction is there. The important thing is that eax (result from sub_401030) is used to calculate the address where the 0 will be stored. 
            
            <p class="lolwat2"> mov [ebp+var_10], eax <br> mov eax, [ebp+var_10] <span class="lolwat"> store the value obtained from sub_401030 into var_10 and place it back into eax..? </span> 
            </p>
        
 
        <p class="lolwat2"> mov [ebp+eax+ <br>
            FindFileData.cAlternate<br>FileName+6], 0<span class="lolwat"> add 0 at the end of cAlternateFileName [null character to denote end of c-string..?] </span> 
            </p>
        <p class="lolwat2"> mov ecx, [ebp+arg_0] <span class="lolwat">store value of arg_0 into ecx</span> 
            </p>
        <p class="lolwat2"> push ecx <span class="lolwat"> pass arg_0 as rightmost argument (3rd) </span> 
            </p>
        <p class="lolwat2"> lea edx, [ebp+var_50] <span class="lolwat"> load address of var_50 into edx </span> 
            </p>
        <p class="lolwat2"> push edx <span class="lolwat"> pass &var_50 as 2nd argument </span> 
            </p>
        
        <p class="lolwat2"> lea eax, <br> [ebp+FindFileData.cFileName] <span class="lolwat"> load address of start of cFileName char array into eax </span> 
            </p>
        <p class="lolwat2"> push eax <span class="lolwat"> pass FindFileData.cFileName as 1st argument </span> 
            </p>
         <p class="lolwat2"> call sub_401220 <span class="lolwat"> sub_401220(FindFileData.cFileName, &var_50, arg_0) </span> 
            </p>
        
        Before executing add esp, 0Ch, let's see how the stack is affected by the above: <br>
        <img src="https://user-images.githubusercontent.com/86342821/144711237-9048c304-4c62-49bc-b6b8-d4766bd21948.png"> <br>
        
        After add esp, 0Ch (12 decimal), we get: 
        
        <img src="https://user-images.githubusercontent.com/86342821/144711481-37276f3b-c204-4195-abcb-49c462eae5ee.png">
        
        And just like in part 1, this "cleans up"/undoes the 3 push instructions above.  
        
        

        </p>
        </details>
    </div>
    
    <div id ="submainbar">
    <details> 
    <summary> 
<h5> Part 3 </h5>
  </summary>
    <p>
    <img src="https://user-images.githubusercontent.com/86342821/144712023-3b08b11d-d549-4080-b1b2-7eebb6bb0ce9.png">
    
    <p class="lolwat2"> mov ecx, [ebp+var_4] <span class="lolwat">store value of var_4 into ecx. (var_4 was set to 0 near the start of this function and hasn't been modified/accessed until now.) </span> 
            </p>
    <p class="lolwat2"> add ecx, 1 <span class="lolwat"> ecx += 1 </span> 
        </p>
    <p class="lolwat2"> mov [ebp+var_4], ecx <span class="lolwat"> store new value of ecx as contents of memory in var_4.</span> 
        </p>
    <p class="lolwat2"> lea edx, [ebp+FindFileData] <span class="lolwat"> load address of FindFileData into edx </span> 
        </p>
        
    <p class="lolwat2"> push edx <span class="lolwat"> pass &FindFileData as the rightmost argument (2nd arg) .</span> 
    </p>
    <p class="lolwat2"> mov eax, [ebp+hFindFile] <span class="lolwat"> store the value of hFindFile into eax. </span> 
    </p>
    
    <p class="lolwat2"> push eax <span class="lolwat"> pass hFindFile as the 1st argument for FindNextFileA. </span> 
    </p>
    
    
    <p class="lolwat2"> call ds:FindNextFileA <span class="lolwat"> FindNextFileA(hFindFile, &FindFileData) </span> 
    </p>
    
    <p class="lolwat2"> test eax, eax <span class="lolwat"> test is bitwise and.  </span> 
    </p>
    
    <p class="lolwat2"> jnz short_loc40142A <span class="lolwat"> take the jump if not zero. aka ZF not set (ZF = 0). For test eax, eax to not set the zero flag, eax MUST be nonzero. eax is nonzero when FindNextFileA is successful, so a file has to be found to continue. </span> 
    </p>
    
    At this point, our stack looks like: 
    
    <img src="https://user-images.githubusercontent.com/86342821/144724200-d00feb9e-65ac-4366-9fd8-88c4011f83b2.png">

    
    </p>
  
  
        </details>
    </div>
    
 </details>
</div>
I see 3 big things here and 2 of them are "new" function calls: *sub_401030* and *sub_401220*. After these two are executed, we look for the next file using FindNextFileA() and if its result is non-zero (successfully found), we take the jump to **loc_40142A**. At loc_40142A, there's an unconditional jmp to loc_4013BE; ie, go back to the start of the section we were just on (loc_4013BE). 

![image](https://user-images.githubusercontent.com/86342821/142778670-aa45b816-9bff-4d9e-88bc-a771e5cb84a7.png)

This seems to be a loop which continues depending on whether or not it was able to find a file. But what are the 2 functions that we don't know doing? Let's see *sub_401030()* first:

![image](https://user-images.githubusercontent.com/86342821/142796301-d9f74a36-4055-40a3-b2c6-468167fbb207.png)

<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    <p>
               
        <img src="https://user-images.githubusercontent.com/86342821/144718727-860fa51c-e198-488b-abbe-9a62abb0f90f.png">
        
        By matching the arguments with their respective parameters, we see that arg_0 = &var_50 <br> and arg_4 = FindFileData.cFileName <br> <br>
        
        At this point, our stack frame looks like: <br>
        
        <img src="https://user-images.githubusercontent.com/86342821/144719180-d869d4e3-6e7a-4565-9dd8-ac380dde1c61.png">
    <p style=" font-weight:501; text-align:left; font-size:130%;"> If you're wondering why the stack diagram is "different" from the last drawing in the previous part, it's b/c the last diagram was the stack for FindNextFileA (Part 3). The one I'm referring back to is Part 1 (since it's sub_401030)  </p>
        <p class="lolwat2"> push ebp <br> mov ebp, esp <span class="lolwat"> function prologue  </span> 
        </p>
    
        <img src="https://user-images.githubusercontent.com/86342821/144719993-3b704a4f-7284-4c0d-815a-837f9af6610d.png">
        <br>
    
        After the function prologue, we have: <br>
    
    <p class="lolwat2"> push ecx <span class="lolwat"> The purpose of this push isn't to save the value of ecx or pass it as an argument. 
        <a href="https://stackoverflow.com/a/22351413">It's an optimization trick. </a></span> 
        </p> <br>
    
    <img src="https://user-images.githubusercontent.com/86342821/144720029-a36c3f79-9f52-49c6-bb7c-855c22d769da.png">

    
    <p class="lolwat2"> mov [ebp+var_4], 0 <span class="lolwat"> Keep in mind var_4 = -4. store 0 as value of memory in var_4. </span> 
        </p> <br>
     <img src="https://user-images.githubusercontent.com/86342821/144720185-d0e7b3cf-3e44-4375-b8ef-e2072f0a21e4.png">
    
     
    <br>
    Now we can take a look at the rest:
    <br> 
    <img src="https://user-images.githubusercontent.com/86342821/144720448-dbede79e-ee94-4728-a5b3-c939e1337cd1.png">
    
    <p class="lolwat2"> mov eax, [ebp+arg_0] <span class="lolwat"> arg_0 = &var_50. eax = start of var_50  </span> 
    </p>
    <p class="lolwat2"> add eax, [ebp+var_4] <span class="lolwat"> value of var_4 = 0 from above; eax += var_4 (eax = var_4th element) </span> 
    </p>
    <p class="lolwat2"> mov ecx, [ebp+arg_4] <span class="lolwat"> store the value of arg_4 (start of cFileName) into eax </span> 
    </p>
    <p class="lolwat2"> add ecx, [ebp+var_4] <span class="lolwat"> ecx += var_4 </span> 
    </p>
    <p class="lolwat2"> mov dl, [ecx] <span class="lolwat"> store the value of [ecx] into dl. accessing var_4th element of arg_4 </span> 
    </p>
    <p class="lolwat2"> mov [eax], dl <span class="lolwat"> store the value of [ecx] into [eax]. var_4th element of var_50 gets replaced with var_4th element of FindFileData.cFileName</span> 
    </p>
    
    <p class="lolwat2"> mov eax, [ebp+arg_4] <span class="lolwat"> store the value of arg_4 into eax (start of cFileName) </span> 
    </p>
    <p class="lolwat2"> add eax, [ebp+var_4]<span class="lolwat"> going to var_4th element of cFileName. </span> 
    </p>
    <p class="lolwat2"> movsx ecx, byte ptr [eax] <span class="lolwat"> get the byte from the (cFileName + var_4) and sign extend the result into ecx </span> 
    </p>
    <p class="lolwat2"> test ecx, ecx <span class="lolwat"> check result of (ecx & ecx) and set flags accordingly. </span> 
    </p>
    <p class="lolwat2"> jnz short loc_40105D <span class="lolwat"> take the jump if not zero. that would require ZF to not be set. ZF is only set if the result from test ecx,ecx is zero. So we jump to loc_40105D if the sign-extended value we get results in 0. </span> 
    </p> <br> 
    
    Let's look at loc_40105D (branch taken when zero flag isn't set):
    
    <img src="https://user-images.githubusercontent.com/86342821/144725179-0e89b4bb-5504-48d7-88ca-94643fbf4687.png"> <br>

    <p class="lolwat2"> mov edx, [ebp+var_4] <span class="lolwat"> edx = value of var_4 </span> 
    </p>
    <p class="lolwat2"> add edx, 1 <span class="lolwat"> edx += 1</span> 
    </p>
    <p class="lolwat2"> mov [ebp+var_4], edx <span class="lolwat"> store edx into value of var_4 [it's keeping count of how many times this is executed] </span> 
    </p>
    <p class="lolwat2"> jmp short loc_40103B <span class="lolwat"> jump back to loc_40103B so loop/repeat until we get 0 from test ecx,ecx. </span> 
    </p>
    

    
    </p>
    
    
 </details>
    </div>

The lowest 8 bits of the 1st argument are replaced with the lowest 8 bits of the 2nd argument. It does so 1 byte at a time until it encounters a byte of the 2nd argument (**arg_4**) that is zero/empty and returns the number of times the loop was executed. I know it's doing some copying and most likely keeping count of the number of bytes that were replaced. I'll call **sub_401030 as retNumBytesArg1ReplByArg2**. 

Lets look at the next function: *sub_401220*.  

![image](https://user-images.githubusercontent.com/86342821/142825918-94d8f2a2-82f2-4163-9302-c04accfc65e7.png)

<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    <p>
        Since our stack is getting a bit long, I'll be omitting the parts that aren't "relevant". Here's what I mean: <br> 
        <img src="https://user-images.githubusercontent.com/86342821/144938799-67e0a5e6-9ab7-46a4-ae41-0ddc3e796f46.png"> <br> 
        Instead of displaying all of the elements prior to the call, only the ones that are used will be kept. (the circled portion above is the relevant part b/c those are the arguments passed through the function we've entered. the rest won't be shown.) <br> <br>
        
        Starting from right before the function prologue: <br> 
        <img src="https://user-images.githubusercontent.com/86342821/144939172-e5651c30-2b0f-4ee9-85b5-b1eabcb1538f.png">
        <br> 
        Right after sub esp, 18h [24 decimal], the space for this function's local variables is allocated:
        
        <img src="https://user-images.githubusercontent.com/86342821/144942861-42e65ad6-63ad-4ac4-84d7-11c19b13cf4a.png"> <br>
        
       Now comes the main part: 
        
         <p class="lolwat2"> push 0 <span class="lolwat"> argument for hTemplateFile (involves handle to a template file). set as NULL (0) b/c this is useless to us. </span> 
    </p>
    <p class="lolwat2"> push 80h <span class="lolwat"> argument for dwFlagsAndAttributes (info regarding file/device attributes and flags; kind of like settings..?) The documentation page shows 80h corresponds to FILE_ATTRIBUTE_NORMAL, which means none of the attributes are set.</span> 
    </p>
    <p class="lolwat2"> push 3 <span class="lolwat"> argument for dwCreationDisposition; 3 corresponds to OPEN_EXISTING, which is described as only opening a file if it exists. </span> 
    </p>
    <p class="lolwat2"> push 0 <span class="lolwat"> argument for lpSecurityAttributes. set as NULL (0) b/c it's useless. </span> 
    </p>
    <p class="lolwat2"> push 1 <span class="lolwat"> argument for dwShareMode; corresponds to FILE_SHARE_READ (which allows a specified file or device to request read access) </span> 
    </p>
    <p class="lolwat2"> push 80000000h <span class="lolwat"> argument for dwDesiredAccess. Unlike the other sections, this one doesn't explicitly say what values the constants they used are. Read your way through or google, but this constant corresponds to GENERIC_READ.</span> 
    </p>
    <p class="lolwat2"> mov eax, [ebp+lpFileName] <span class="lolwat">corresponds to the file/device's name that'll be accessed. store in eax. </span> 
    </p>
    <p class="lolwat2"> push eax <span class="lolwat">  argument for lpFileName. eax contains data of lpFileName from previous line.</span> 
    </p>
     <p class="lolwat2"> call ds:CreateFileA <span class="lolwat"> CreateFileA(lpFileName, 80000000h, 1, 0, 3, 80h, 0) return any number other than -1 (0x0FFFFFFF) on success. result of -1 = fail.</span> 
    </p>
    <p class="lolwat2">mov [ebp+hFile], eax <span class="lolwat"> move the result of CreateFileA into memory contents of hFile.</span> 
    </p>
    <p class="lolwat2"> cmp [ebp+hFile], 0FFFFFFFh <span class="lolwat"> compare the result of CreateFileA with 0x0FFFFFF (-1 decimal). if the result is 0x0FFFFFFF, the zero flag is set (since 0x0FFFFFFF - 0x0FFFFFFF = 0), which means CreateFileA failed. </span> 
    </p>
     <p class="lolwat2"> jnz short loc_401254 <span class="lolwat"> If the zero flag isn't set, take the jump. ZF is set if CreateFileA fails, so we only take the jump if CreateFileA was successful. </span> 
    </p>

    
    <br> <br>
    if you've come this far for this help bar, what does the stack look like now? (hint: continue from the diagram of the most recent frame)



        
        
        
        
    </p>
 </details>
</div>
[CreateFileA](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) is called, which returns a non-zero value corresponding to a valid handle on success. Otherwise, it returns *INVALID_HANDLE_VALUE* (*0x0FFFFFFFh* [-1 in decimal]) on failure. Let's take a look at the arguments of the function to get a better understanding of what's going on:

![image](https://user-images.githubusercontent.com/86342821/142949004-d694680e-379f-43de-a8dd-f2ae44a3e054.png)

Because the parameters *lpSecurityAttributes* and *hTemplateFile* are **optional** and aren't used in this scenario (both have *0* as their arguments), we'll be excluding them. By using the table provided above, we can see that this call of CreateFileA will attempt to open (with read access) a file/device with the name provided as *lpFileName* **only if the file exists**. Otherwise, it returns an **error** indicating that the file was **not found** and subsequently executes **printsError()**.

Let's take the jump to **loc_401254**:

![image](https://user-images.githubusercontent.com/86342821/143002090-b7d40131-6bd0-4986-b5cc-f6bc859c32df.png)

<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    
    <p style="font-weight:501; font-size: 50px; text-align:center">
        left as an "exercise" for the reader <br> (if needed)
    <img src="/images/jerrleft.png" style="max-width:20%;">
    </p>

 </details>
</div>
*Another* call to CreateFileA. Compared to the first call, this one passes along different values for 3 of the parameters: *dwDesiredAccess*, *dwShareMode*, and *dwCreationDisposition* (*GENERIC_WRITE* (*0x40000000*), *0*, and *CREATE_ALWAYS* (*2*), as arguments, respectively). If we refer to the table posted earlier and [seek out extra info regarding CreateFileA](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea), we know this second call will **always** attempt to create a file (or if it already exists, overwrite its contents) with the name from *lpFileName* and **prevent other processes from requesting delete, read, or write access** to that specific file/device.

What happens now?

If we continue onto **loc_401282**, we see the following:

![image](https://user-images.githubusercontent.com/86342821/144987379-1baf6f53-4e24-4f2f-8662-239ac729724d.png)

<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    <p>
        The stack diagrams keep on stacking in length, so any remaining ones are left to the reader as exercises :^) [the "important" stuff regarding visualizing the stack was covered in the previous parts, so refer to those if needed]. <br> <br> 
        
        Make sure to <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">refer to the documentation </a> so that the values for each argument makes sense. 
        
        <p class="lolwat2"> push 0 <span class="lolwat"> argument for lpOverlapped; set as NULL (0) b/c it's useless to us.</span> 
    </p>
    <p class="lolwat2"> lea ecx, [ebp+NumberOfBytesRead] <span class="lolwat"> load the address of NumberOfBytesRead into ecx </span> 
    </p>
     <p class="lolwat2"> push ecx <span class="lolwat"> pass the address of NumberOfBytesRead as the argument for lpNumberOfBytesRead </span> 
    </p>
    <p class="lolwat2"> push 8 <span class="lolwat"> corresponds to parameter nNumberOfBytesToRead. Read at most 8 bytes. </span> 
    </p>
     <p class="lolwat2"> lea edx, [ebp+Buffer] <span class="lolwat"> load the address of Buffer into edx </span> 
    </p>
    <p class="lolwat2"> push edx <span class="lolwat"> pass the address of Buffer as the argument for lpBuffer </span> 
    </p>
    <p class="lolwat2"> mov eax, [ebp+hFile] <span class="lolwat"> store the value of hFile into eax </span> 
    </p>
    <p class="lolwat2"> push eax <span class="lolwat"> pass the value of hFile (handle to the file) as the argument for hFile </span> 
    </p>
      <p class="lolwat2"> call ds:ReadFile <span class="lolwat"> ReadFile(hFile, &Buffer, 8, &NumberOfBytesRead, 0) </span> 
    </p>
        <p class="lolwat2"> test eax, eax <span class="lolwat"> bitwise-and eax and set flags accordingly </span> 
    </p>
      <p class="lolwat2"> jnz short loc_4012A5 <span class="lolwat"> If not zero, aka the zero flag isn't set, take the jump. ZF is set from the previous instruction if eax == 0. So, we take the jump if ReadFile returns a non-zero value (aka successful) </span> 
    </p>
        
    </p>
 </details>
</div>
[*ReadFile*](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile) reads the data from *hFile* and stores it into *Buffer*. It reads at most 8 bytes at once, and if successful, returns a nonzero value. Otherwise, it returns zero. 

Upon success, we jump to **loc_4012A5**:

![image](https://user-images.githubusercontent.com/86342821/143136181-f1b79dfb-ed10-4118-ab7b-603d3080fa4b.png)

The number of bytes read from *hFile* is checked, and if it's more than zero, we continue onto **loc_4012AD**. Unlike the other branch fails, this one doesn't result in a call to **printsError**. Instead, we jump to **loc_4012E4** where the current function we're exploring (*sub_401220*) ends. Let's first examine the branch we take upon success (**loc_4012AD**):

![image](https://user-images.githubusercontent.com/86342821/144986789-f51159f4-89dd-42b1-b3eb-326206075678.png)

<br> 

We see two function calls here: *sub_4011F0* and *WriteFile*. It looks like *sub_4011F0* does something with *Buffer* and ***arg_8***? 

<div class = "myWay">
    <img src="/images/stare3.png">
    </div>
    
***arg_8***..? 

If we go back to the beginning of the current function (*sub_401220*), it shows that arg_8 corresponds to the *rightmost* argument that was passed. Let's retrace our steps to determine what arg_8 is...   

![image](https://user-images.githubusercontent.com/86342821/143326677-8e6054b0-d8f1-462a-b808-5d702e8ac6de.png)

At the start of *sub_401220*, the function prototype is provided: 

```
int __cdecl sub_401220(LPCSTR lpFileName, LPCSTR, int)
```

If we go "back" and see where this function was executed, we find ourselves in **doesSomethingAndRetExitCode** at **loc_4013BE**. Since we're looking for the rightmost argument, we want the ***first*** argument that was pushed onto the stack. ECX was the 1st thing passed onto the stack prior to calling *sub_401220*. It contains the memory contents of **arg_0**, which was passed through as *the* argument (ie, only 1) for **doesSomethingAndRetExitCode**. This means we just have to figure out what was passed as an argument when **doesSomethingAndRetExitCode** was called. 

If we look at the beginning of the figure above, we can see that in **start** (label 3), the address of **Buffer** is loaded into EAX with the LEA instruction. EAX is then pushed onto the stack to be used as an argument for **doesSomethingAndRetExitCode**. Near the start of this challenge, we discovered that the Buffer variable stores at most ***8 characters*** of the user input obtained using *ReadConsoleA*. Therefore, we can safely say that **arg_8 is the user input; ie, the decryption key** the user is asked to enter.

Continuing from where we left off earlier, we now run *sub_4011F0*:
 
```
sub_4011F0(&Buffer, arg_8)
```

where &Buffer corresponds to *arg_0* and arg_8 to *arg_4*. In other words, **&Buffer** aka **arg_0** represents **data read from the file** while **arg_8** aka **arg_4** represents the **user input from ReadConsole()**. 

The function can be broken down as follows:

![image](https://user-images.githubusercontent.com/86342821/144558080-7c2d8423-3d07-4a57-a9cb-384dd17c6a1d.png)

<div id= "mainbar">
<details> 
    <summary> 
<h5> How did I get: </h5>
  </summary>
    
    <div id ="submainbar">
    <details> 
    <summary> 
<h5> Part 1 </h5>
  </summary>
        <p>
            
            <img src="https://user-images.githubusercontent.com/86342821/144720901-41a460f6-64ba-4381-8a52-54334e20150d.png">

        <p class="lolwat2"> push ebp <br> mov ebp, esp <span class="lolwat"> function prologue </span> 
            </p>
        
        <p class="lolwat2"> push ebx <br> push esi <br> push edi <br> <span class="lolwat"> <a href="https://en.wikibooks.org/wiki/X86_Assembly/High-Level_Languages">These are non-volatile registers and their values need to be preserved. </a> </span> 
            </p>
        
        <p class="lolwat2"> mov edi, [ebp+arg_0] <span class="lolwat"> contents of arg_0 stored in edi [so edi corresponds to the file data] </span> 
            </p>
        <p class="lolwat2"> mov esi, [ebp+arg_4] <span class="lolwat"> contents of arg_4 stored in esi [so esi corresponds to the user input] </span> 
            </p>
        <p class="lolwat2"> xor ecx, ecx <span class="lolwat"> optimization trick to set ecx to 0. </span> 
            </p>
        
        </p>
        </details>
    </div>
    
    <div id ="submainbar">
    <details> 
    <summary> 
<h5> Part 2 </h5>
  </summary>
        <p>
        <img src="https://user-images.githubusercontent.com/86342821/144722822-ee62e9c1-29b0-4f3e-8d6d-ee29e89c48af.png">
        Googling "rol x86" showed me that rol <a href="https://c9x.me/x86/html/file_module_x86_id_273.html"> stands for rotate left </a>
            
        <p class="lolwat2"> cmp cl, 8 <span class="lolwat"> is the 1st 8 bits (or byte) of ecx (which was just zeroed out) equal to 8? set flags accordingly. </span> 
        </p>
        <p class="lolwat2"> jge short loc_401216 <span class="lolwat"> take the jump if cl >= 8. </span> 
        </p>
        if cl < 8:
         <p class="lolwat2"> mov bl, [ecx+esi] <span class="lolwat">esi corresponds to user input so bl does too. </span> 
        </p>
        <p class="lolwat2"> mov al, [ecx+edi] <span class="lolwat"> edi corresponds to the file data, so al does too. </span> 
        </p>
        
        <p class="lolwat2"> xor al, bl <span class="lolwat"> al = (al ^ bl) </span> 
        </p>
        <p class="lolwat2"> rol al, cl <span class="lolwat"> al = al ROL cl    since al = (a1^bl) above, we get: al =((al ^ bl) ROL cl) </span> 
        </p>
        <p class="lolwat2"> sub al, cl <span class="lolwat"> al = al - cl      since al = ((al ^ bl) ROL cl) above, we get result = (((al ^ bl) ROL cl) - cl)</span> 
        </p>
        <p class="lolwat2"> mov [ecx+edi] , al <span class="lolwat"> store the result of the computation above back into edi (file data). </span> 
        </p>
        <p class="lolwat2"> inc cl<span class="lolwat"> cl+= 1 </span> 
        </p>
        <p class="lolwat2"> jmp short loc_4011FE <span class="lolwat"> jump back to section where we compare if cl >= 8 </span> 
        </p>
        
        if cl >= 8:
        <p class="lolwat2"> pop edi <br> pop esi <br> pop ebx <br> pop ebp <span class="lolwat"> restore registers to their values prior to us changing them here </span> 
        </p>
        
        </p>
        </details>
    </div>
    
    
 </details>
</div>

It looks like the user input and the file data are being used 8 bytes at a time for something...

And it just so happens to involve ***rol*** and ***sub*** when the clue we discovered earlier mentioned ***ror*** and ***add***.

<img src="/images/smugdoge.png" style="display: inline; width: 120px; ">

This might be just what we were looking for. Let's take a closer look at what's happening.

#### Understanding the function's function 

![image](https://user-images.githubusercontent.com/86342821/144700618-ad52e1b7-a4f9-4f59-8e3a-841756ebd4d2.png)

This starts with a check to see if some number (let's call it ***someNumber***) is greater than or equal to 8. It's initially set to 0 so it cycles through numbers  0 to 7. We can see here that **bl** corresponds to the **user's input** and **al** to the **file data**. Each byte of the file data is XORed with those of the user's input and then rotated to the left ***someNumber*** of times. The result is then subtracted by ***someNumber*** and then ***someNumber*** is incremented. This is repeated until there's no more data to go through.



<p class="lolwat2"> mov bl, [ecx+esi] <span class="lolwat"> bl corresponds to user input</span> 
            </p>
            
<p class="lolwat2"> mov al, [ecx+edi] <span class="lolwat"> al corresponds to file data </span> 
            </p>
<p class="lolwat2"> xor al,bl <span class="lolwat"> al = al ^ bl </span> 
            </p>
            
<p class="lolwat2"> rol al, cl <span class="lolwat"> al = al ROL cl [replace al with (al ^ bl)] and we get: <br> (al ^ bl) ROL cl </span> 
            </p>
<p class="lolwat2"> sub al, cl <span class="lolwat"> al = al - cl [replace al with ((al ^ bl) ROL cl) and we get: <br> (((al ^ bl) ROL cl) - cl)</span> 
            </p>
            
<p class="lolwat2"> mov [ecx+edi], al <span class="lolwat"> store the result al from above into memory contents of ecx+edi. (edi corresponds to file data so the file's bytes are directly replaced by the result of (((al ^ bl) ROL cl) - cl) </span></p>

<p class="lolwat2"> inc cl <span class="lolwat"> cl += 1 </span> 
</p>
<p class="lolwat2"> jmp short loc_4011FE <span class="lolwat"> go to loc_4011FE where cl is checked if it's greater than or equal to 8. if it is, exit the function. if not, continue until 8. </span> 
</p>

At this point, it might be intuitive to perform the inverse of the algorithm above for the solution (there's also the fact that ***ror+add*** was provided as a hint). Ironically, this wasn't the approach I took when I solved this at the time. I was spooked by the thought of working with the inverse of ROL 

<img src="/images/nickyoung.png" style="display: inline;">

and decided to solve it this way only if I were unable to come across a reasonable method.

The alternative I thought of relied on the idea that, when decrypted, the *latin_alphabet.txt* file would correspond to the alphabet (ABC...). Since 1 character was represented by a single byte, I was sure that we were working with ASCII (only 256 vals). So I cycled through all 256 characters with the encrypted file bytes and printed out the ones that matched our expected values (eg: A = (ROL((encrypted_byte_of_A ^ ***nth_char***), i) - i); the nth_char would be printed).


Let's see what happens:


## Solution

Below contains my solution for obtaining the key. It's not elegant but it got the job done w/o problems.  

**main.cpp**
```
#include <fstream>
#include <Windows.h>
#include "rol.h"

// hex data obtained from latin_alphabet.txt.encrypted
const BYTE encrypted[26] = { 0x0F, 0xCE, 0x60, 0xBC, 0xE6, 0x2F,
                             0x46, 0xEA, 0x07, 0xCA, 0X62, 0xBD,
                             0x67, 0xEF, 0x26, 0xDA, 0x1F, 0xC6,
                             0x64, 0xBE, 0xE7, 0xAF, 0x06, 0xCA, 0x17, 0xC2 };


// hex data for A-Z
const BYTE expected[26] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
                            0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                            0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,
                            0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A };


void printcHex(BYTE a) {
    printf("ASCII: %c , Hex: %02x \n", a, a);
}

void decrypt(BYTE* a1) {
    int i = 0;
    BYTE decrypted = 0;
    int count = 0;
    for (i = 0; i < 8; i++) {
        BYTE encrypted = *(BYTE*)(i + a1); // a1[i]
        
        //try all 256 possible characters in ASCII
        for (int key = 0; key < 256; key++) {
            decrypted = __ROL1__(key ^ encrypted, i) - i;
            
            //got a match? print it and look for the next letter
            if (decrypted == expected[count]) {
                printcHex(key);
                break;
            }
        }
        count += 1;
    }
}

int main() {

    BYTE* b = new BYTE[8];
    
    for (int i = 0; i < 8; i++) {
        b[i] = encrypted[i];
    }
    decrypt(b);
    
    delete b;

    return 0;
}

```

**rol.h**
```
/*
* https://reverseengineering.stackexchange.com/questions/12976/hex-rays-strange-functions-rol4-and-ror4
* 
*   Copyright (c) 2007-2017 Hex-Rays
*/
typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef long long       int64;
typedef long long       sint64;
typedef unsigned long long uint64;

template<class T>  int16 __PAIR__(int8  high, T low) { return (((int16)high) << sizeof(high) * 8) | uint8(low); }
template<class T>  int32 __PAIR__(int16 high, T low) { return (((int32)high) << sizeof(high) * 8) | uint16(low); }
template<class T>  int64 __PAIR__(int32 high, T low) { return (((int64)high) << sizeof(high) * 8) | uint32(low); }
template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) << sizeof(high) * 8) | uint8(low); }
template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) << sizeof(high) * 8) | uint16(low); }
template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) << sizeof(high) * 8) | uint32(low); }

// rotate left
template<class T> T __ROL__(T value, int count)
{
    const uint nbits = sizeof(T) * 8;

    if (count > 0)
    {
        count %= nbits;
        T high = value >> (nbits - count);
        if (T(-1) < 0) // signed value
            high &= ~((T(-1) << count));
        value <<= count;
        value |= high;
    }
    else
    {
        count = -count % nbits;
        T low = value << (nbits - count);
        value >>= count;
        value |= low;
    }
    return value;
}

inline uint8  __ROL1__(uint8  value, int count) { return __ROL__((uint8)value, count); }

```

After running the code above, we get the output shown below:

![image](https://user-images.githubusercontent.com/86342821/143663234-5563e653-b035-4d32-804b-d53540911998.png)


> No1Trust

Let's enter it in and see what happens... 

![image](https://user-images.githubusercontent.com/86342821/143196404-460d2bf6-d579-4ecb-a252-7dc64429e128.png)

If the key we provided was correct, then the decrypted set of files shouldn't be gibberish. Let's check ***latin_alphabet.txt*** (since our solution was based off the idea that this file corresponds to the 26 letters of the alphabet).    

<p style="font-weight: 501; color:#3d63fb; font-size: 22px;">latin_alphabet.txt </p>
![image](https://user-images.githubusercontent.com/86342821/143197163-ce071a50-4c31-4221-932a-349805cef94e.png)

<div class = "myWay">
    <img src="/images/peepoteethsmile.png">
    </div> Let's check another file to make sure this wasn't a fluke.

<p style="font-weight: 501; color:#3d63fb; font-size: 22px;">capa.png </p>
![image](https://user-images.githubusercontent.com/86342821/144657560-81ab2a40-b8f2-4972-8ff1-60b90f5d38ac.png)

Now for the moment of truth: 

<p style="font-weight: 501; color:#3d63fb; font-size: 22px;" >critical_data.txt </p>
![image](https://user-images.githubusercontent.com/86342821/143197227-f03f987c-112b-4ba0-a9d3-b647887c09d4.png)

> (>0_0)> You_Have_Awakened_Me_Too_Soon_EXE@flare-on.com <(0_0<)

<div class = "myWay">
    <img src="/images/duckyaytransparentright.gif">
</div>

We did it :)

<br> 

> **Key**: No1Trust
> 
> **Flag**: You_Have_Awakened_Me_Too_Soon_EXE@flare-on.com






